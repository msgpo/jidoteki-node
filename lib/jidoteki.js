// Generated by CoffeeScript 1.6.3
/*
 * Jidoteki - https://jidoteki.com
 * Build virtual appliances using Jidoteki
 * Copyright (c) 2014 Alex Williams, Unscramble <license@unscramble.jp>
*/


(function() {
  var api, armrest, crypto, settings,
    _this = this,
    __slice = [].slice;

  crypto = require('crypto');

  armrest = require('armrest');

  settings = {
    endpoint: process.env.JIDOTEKI_ENDPOINT || 'https://api.jidoteki.com',
    userid: process.env.JIDOTEKI_USERID || 'change me',
    apikey: process.env.JIDOTEKI_APIKEY || 'change me',
    useragent: 'nodeclient-jidoteki/0.1.8',
    token: null
  };

  api = armrest.client(settings.endpoint);

  exports.settings = settings;

  exports.makeHMAC = function(string, callback) {
    return callback(crypto.createHmac('sha256', settings.apikey).update(string).digest('hex'));
  };

  exports.getToken = function(callback) {
    var resource;
    resource = '/auth/user';
    return this.makeHMAC("POST" + settings.endpoint + resource, function(signature) {
      return api.post({
        url: resource,
        headers: {
          'X-Auth-Uid': settings.userid,
          'X-Auth-Signature': signature,
          'User-Agent': settings.useragent,
          'Accept-Version': 1,
          'Content-Type': 'application/json'
        },
        complete: function(err, res, data) {
          if (err) {
            return callback(err);
          } else if (data.status === 'success') {
            settings.token = data.content;
            return callback(data);
          }
        }
      });
    });
  };

  exports.getData = function(resource, callback) {
    return this.makeHMAC("GET" + settings.endpoint + resource, function(signature) {
      return api.get({
        url: resource,
        headers: {
          'X-Auth-Token': settings.token,
          'X-Auth-Signature': signature,
          'User-Agent': settings.useragent,
          'Accept-Version': 1
        },
        complete: function(err, res, data) {
          if (err) {
            return callback(err);
          } else {
            return callback(data);
          }
        }
      });
    });
  };

  exports.postData = function(resource, string, callback) {
    return this.makeHMAC("POST" + settings.endpoint + resource + (JSON.stringify(string)), function(signature) {
      return api.post({
        url: resource,
        params: string,
        headers: {
          'X-Auth-Token': settings.token,
          'X-Auth-Signature': signature,
          'User-Agent': settings.useragent,
          'Accept-Version': 1,
          'Content-Type': 'application/json'
        },
        complete: function(err, res, data) {
          if (err) {
            return callback(err);
          } else {
            return callback(data);
          }
        }
      });
    });
  };

  exports.makeRequest = function() {
    var apiCall, callback, getNewToken, handleResult, method, requestMethod, resource, string, tries, _i;
    requestMethod = arguments[0], resource = arguments[1], string = 4 <= arguments.length ? __slice.call(arguments, 2, _i = arguments.length - 1) : (_i = 2, []), callback = arguments[_i++];
    method = requestMethod.toUpperCase();
    tries = 0;
    apiCall = function() {
      switch (method) {
        case "GET":
          return _this.getData(resource, function(result) {
            return handleResult(result);
          });
        case "POST":
          return _this.postData(resource, string[0], function(result) {
            return handleResult(result);
          });
      }
    };
    handleResult = function(result) {
      if (result.status === 'error' && result.message === 'Unable to authenticate' && tries < 1) {
        tries = 1;
        return getNewToken(result);
      } else {
        return callback(result);
      }
    };
    getNewToken = function(result) {
      return _this.getToken(function(result) {
        if (result.status === 'success') {
          return apiCall();
        } else {
          return callback(result);
        }
      });
    };
    if (settings.token != null) {
      return apiCall();
    } else {
      return getNewToken();
    }
  };

}).call(this);
